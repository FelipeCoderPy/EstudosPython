import pyodbc
import mysql.connector
from mysql.connector import Error
import time
import os

# Configura√ß√µes do banco de origem (SQL Server)
source_config_sqlserver = {
    'driver': 'ODBC Driver 17 for SQL Server',
    'server': '192.168.4.193',
    'database': 'db_robbu',
    'uid': 'fecsantos',
    'pwd': 'dYAvWcBZe2GspzQZBIg1'
}

# Configura√ß√µes do banco de destino (MySQL)
dest_config = {
    'host': '172.25.100.14',
    'database': 'Robbu',
    'user': 'fecsantos',
    'password': '@Fec13022025'
}

BATCH_SIZE = 50000
OFFSET_FILE = "offset_status_status.txt"

# Filtro de datas (ajuste se quiser)
DATA_INICIO = '2025-07-01'
DATA_FIM = '2025-07-31 23:59:59'

# Colunas em comum (origem)
common_columns = [
    "id_message",
    "sender_message",
    "sentToProviderAt_message",
    "deliveredAt_message",
    "readAt_message",
    "failedAt_message",
    "errorCode_message",
    "digitalPostman",
    "robbuid_contact"
]

# Mapeamento para renomear colunas na inser√ß√£o
column_mapping = {
    "errorMessage_message": "errormessage"
}

def get_current_offset():
    if os.path.exists(OFFSET_FILE):
        with open(OFFSET_FILE, "r") as f:
            return int(f.read().strip())
    return 0

def save_current_offset(offset):
    with open(OFFSET_FILE, "w") as f:
        f.write(str(offset))

def transfer_data():
    try:
        # Conex√£o SQL Server (origem)
        source_conn = pyodbc.connect(
            f"DRIVER={source_config_sqlserver['driver']};"
            f"SERVER={source_config_sqlserver['server']};"
            f"DATABASE={source_config_sqlserver['database']};"
            f"UID={source_config_sqlserver['uid']};"
            f"PWD={source_config_sqlserver['pwd']}"
        )
        source_cursor = source_conn.cursor()

        # Conex√£o MySQL (destino)
        dest_conn = mysql.connector.connect(**dest_config)
        dest_cursor = dest_conn.cursor()

        offset = get_current_offset()
        print(f"üìç Iniciando transfer√™ncia a partir da linha {offset}...")

        sql_columns = ", ".join(common_columns)
        while True:
            query = f"""
                SELECT {sql_columns}
                FROM [db_robbu].[dbo].[status] WITH (NOLOCK)
                WHERE sentToProviderAt_message BETWEEN ? AND ?
                ORDER BY (SELECT NULL)
                OFFSET {offset} ROWS FETCH NEXT {BATCH_SIZE} ROWS ONLY
            """
            source_cursor.execute(query, (DATA_INICIO, DATA_FIM))
            fetched = source_cursor.fetchall()

            if not fetched:
                print("‚úÖ Todos os dados foram transferidos.")
                break

            rows = [tuple(row) for row in fetched]

            # Colunas destino com mapeamento
            dest_columns = [column_mapping.get(col, col) for col in common_columns]
            col_names_str = ", ".join(dest_columns)
            placeholders = ", ".join(["%s"] * len(dest_columns))

            insert_query = f"INSERT IGNORE INTO status ({col_names_str}) VALUES ({placeholders})"

            dest_cursor.executemany(insert_query, rows)
            dest_conn.commit()

            offset += BATCH_SIZE
            save_current_offset(offset)

            print(f"üöö {offset} linhas transferidas com sucesso...")

    except Exception as e:
        print(f"‚ùå Erro durante transfer√™ncia: {e}")
        print("O progresso foi salvo. Voc√™ pode reiniciar o script sem perder dados.")

    finally:
        if 'source_cursor' in locals(): source_cursor.close()
        if 'dest_cursor' in locals(): dest_cursor.close()
        if 'source_conn' in locals(): source_conn.close()
        if 'dest_conn' in locals(): dest_conn.close()
        print("üîí Conex√µes encerradas.")

if __name__ == "__main__":
    start_time = time.time()
    transfer_data()
    print(f"‚è±Ô∏è Conclu√≠do em {round(time.time() - start_time, 2)} segundos.")
