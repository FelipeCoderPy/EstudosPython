import pyodbc
import mysql.connector
from mysql.connector import Error
import time
import os
import sys

# Nome do processo (define o nome do arquivo de offset)
PROCESS_NAME = sys.argv[1] if len(sys.argv) > 1 else "default_process"
OFFSET_FILE = f"offset_{PROCESS_NAME}.txt"

# Configura√ß√µes do banco de origem (SQL Server)
source_config_sqlserver = {
    'driver': 'ODBC Driver 17 for SQL Server',
    'server': '192.168.4.193',
    'database': 'db_robbu',
    'uid': 'fecsantos',
    'pwd': 'dYAvWcBZe2GspzQZBIg1'
}

# Configura√ß√µes do banco de destino (MySQL)
dest_config = {
    'host': '172.25.100.14',
    'database': 'Robbu',
    'user': 'fecsantos',
    'password': '@Fec13022025'
}

BATCH_SIZE = 50000

# Datas de filtro
DATA_INICIO = '2025-07-01'
DATA_FIM = '2025-07-31 23:59:59'

# Colunas que existem em ambas as tabelas
common_columns = [
    "dt_message",
    "directionId",  # ser√° renomeado para "direction"
    "id",
    "channel",
    "type",
    "text",
    "countryCodeSource",
    "phoneNumberSource",
    "senderSource",
    "countryCode_destination",
    "phoneNumber_destination",
    "robbuid_contact",
    "lastWalletCodeContact",
    "name_contact",
    "customCode_contact",
    "countryCode_mainWhatsapp",
    "phoneNumber_mainWhatsapp",
    "countryCode_Sms",
    "phoneNumber_Sms",
    "digitalPostman",
    "number_protocol",
    "emailSource"  # ser√° renomeado para "email_source"
]

# Mapeamento para renomear colunas na inser√ß√£o
column_mapping = {
    "directionId": "direction",
    "emailSource": "email_source"
}

def get_current_offset():
    if os.path.exists(OFFSET_FILE):
        with open(OFFSET_FILE, "r") as f:
            return int(f.read().strip())
    return 0

def save_current_offset(offset):
    with open(OFFSET_FILE, "w") as f:
        f.write(str(offset)) 

def transfer_data():
    try:
        # Conex√£o com SQL Server (origem)
        source_conn = pyodbc.connect(
            f"DRIVER={source_config_sqlserver['driver']};"
            f"SERVER={source_config_sqlserver['server']};"
            f"DATABASE={source_config_sqlserver['database']};"
            f"UID={source_config_sqlserver['uid']};"
            f"PWD={source_config_sqlserver['pwd']}"
        )
        source_cursor = source_conn.cursor()

        # Conex√£o com MySQL (destino)
        dest_conn = mysql.connector.connect(**dest_config)
        dest_cursor = dest_conn.cursor()

        offset = get_current_offset()
        print(f"üìç Iniciando transfer√™ncia a partir da linha {offset} (arquivo: {OFFSET_FILE})...")

        sql_columns = ", ".join(common_columns)
        while True:
            query = f"""
                SELECT {sql_columns}
                FROM [db_robbu].[dbo].[message] with (nolock)
                WHERE dt_message BETWEEN ? AND ?
                ORDER BY (SELECT NULL)
                OFFSET {offset} ROWS FETCH NEXT {BATCH_SIZE} ROWS ONLY
            """
            source_cursor.execute(query, (DATA_INICIO, DATA_FIM))
            fetched = source_cursor.fetchall()

            if not fetched:
                print("‚úÖ Todos os dados foram transferidos.")
                break

            rows = [tuple(row) for row in fetched]

            # Renomear colunas conforme necess√°rio
            dest_columns = [column_mapping.get(col, col) for col in common_columns]
            col_names_str = ", ".join(dest_columns)
            placeholders = ", ".join(["%s"] * len(dest_columns))
            insert_query = f"INSERT IGNORE INTO message ({col_names_str}) VALUES ({placeholders})"

            dest_cursor.executemany(insert_query, rows)
            dest_conn.commit()

            offset += BATCH_SIZE
            save_current_offset(offset)

            print(f"üöö {offset} linhas transferidas com sucesso...")

    except Exception as e:
        print(f"‚ùå Erro durante transfer√™ncia: {e}")
        print("O progresso foi salvo. Voc√™ pode reiniciar o script sem perder dados.")

    finally:
        if 'source_cursor' in locals(): source_cursor.close()
        if 'dest_cursor' in locals(): dest_cursor.close()
        if 'source_conn' in locals(): source_conn.close()
        if 'dest_conn' in locals(): dest_conn.close()
        print("üîí Conex√µes encerradas.")

if __name__ == "__main__":
    start_time = time.time()
    transfer_data()
    print(f"‚è±Ô∏è Conclu√≠do em {round(time.time() - start_time, 2)} segundos.")
